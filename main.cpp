
#include "MapGen.cpp"
#include "Render.cpp"
#include "UI.cpp"
#include "Isometric.cpp"
#undef main

#include "Utilities.h"



// Call this once during each render loop in order to determine when the user wishes to terminate the program
bool ProcessInput(int *mouseX, int* mouseY)
{
    // Return this value to tell the caller whether or not it should continue rendering
    // We will terminate the application if any key is pressed
    bool keepRenderLoopRunning = true;

    // Events are generated by SDL whenever something occurs system-wide
    // We are only interested in keyboard events and when the user closes the window
    // We will terminate the application if a key is pressed or if the window is manually closed
    SDL_Event event;

    // Process all events and return whether or not to quit
    while (SDL_PollEvent(&event))
    {
        // Handle relevant SDL events
        switch (event.type)
        {
        case SDL_MOUSEMOTION:
            *mouseX = floor(event.button.x / (g_kWindowWidth / g_kRenderWidth));
            *mouseY = floor(event.button.y / (g_kWindowHeight / g_kRenderHeight));
            break;
            // Terminate application if a key is pressed or if the user closes the window
        
        case SDL_KEYDOWN:
            switch( event.key.keysym.sym ){
                case SDLK_ESCAPE:
                    keepRenderLoopRunning = false;
                    break;
            }
            break;

        case SDL_QUIT:
            keepRenderLoopRunning = false;
            break;
        
        }
    }

    // Let the caller know if it should continue rendering, otherwise terminate
    return keepRenderLoopRunning;
}

int main()
{
    bool Arthur = true;
    SDL_Window* pWindow = nullptr;
    SDL_Renderer* pRenderer = nullptr;
    SDL_Texture* pTexture = nullptr;

    UI mainUI;
    
    if (e(Render::Startup(&pWindow, &pRenderer, &pTexture), "Startup Failed. Aborting...\n"))
    {
        Render::Shutdown(&pWindow, &pRenderer, &pTexture);
        return -1;
    }

    bool running = true;
    bool firstFrame = true;

    uint64_t totalTicks = 0;
    uint64_t totalFramesRendered = 0;
    uint64_t lastTick = 0;

    uint32_t * pixelBuffer;
    pixelBuffer = (uint32_t *)malloc(g_kRenderHeight * g_kRenderWidth * sizeof(uint32_t));

    MapGen map = MapGen(0, g_kRenderWidth, g_kRenderHeight, 3, 2.5f, 0.2f);
    
    int i = 0;
    int j = 0;
    int mouseX = 0;
    int mouseY = 0;
    int mouseChunkX = 0;
    int mouseChunkY = 0;
    float pos = 1;

    while (running)
    {
        if (firstFrame)
        {
            lastTick = SDL_GetPerformanceCounter();
            firstFrame = false;
            // for (int y = 0; y < g_kRenderHeight; y ++){
            //     for (int x = 0; x < g_kRenderWidth; x ++){
            //         // if (CLAMP((int)(map.index[y * g_kRenderWidth + x] * 128 + 128), 0, 255) > 170){
            //         //     pixelBuffer[y * g_kRenderWidth + x] = ARGB(0, 0, 0, 255);
            //         // }
            //         // else{
            //         //     pixelBuffer[y * g_kRenderWidth + x] = ARGB(255, 255, 255, 255);
            //         // }
            //         pixelBuffer[y * g_kRenderWidth + x] = ARGB(CLAMP((int)(map.index[y * g_kRenderWidth + x] * 128 + 128), 0, 255), CLAMP((int)(map.index[y * g_kRenderWidth + x] * 128 + 128), 0, 255), CLAMP((int)(map.index[y * g_kRenderWidth + x] * 128 + 128), 0, 255), 255);
            //     }
            // }
            // Sprites
            mainUI.addSprite("ISO-test", "sprites/iso-test.bmp", pWindow, pRenderer);
        }
        else
        {
            SDL_RenderClear(pRenderer);
            // if (e(Render::RenderTexture(pWindow, pRenderer, pTexture, pixelBuffer), "Render failed\n")) break;
            pos +=0.5f;
            for (int x = 0; x < g_kRenderHeight/4; ++x){
                for (int y = 0; y < g_kRenderHeight/4; ++ y){
                    Isometric::ConvertToIsometricCoord(x, y, &i, &j, 32, 32);
                    mainUI.drawSprite("ISO-test", i + g_kRenderWidth - 16 , j - g_kRenderHeight + 16 + map.getNoise(x * 4 + pos, y * 4) * 512, pRenderer);
                }
            }
            SDL_RenderPresent(pRenderer);

            running = ProcessInput(&mouseX, &mouseY);
            Isometric::ConvertFromIsometricCoord(mouseX, mouseY, &mouseChunkX, &mouseChunkY, 32, 32);

            uint64_t currentTick = SDL_GetPerformanceCounter();
            totalTicks += currentTick - lastTick;
            lastTick = currentTick;
            ++totalFramesRendered;
        }
    }
  
    // Display render and timing information
    std::cout << "Total Frames:    " << totalFramesRendered << "\n";
    std::cout << "Total Time:      " << static_cast<double>(totalTicks) / SDL_GetPerformanceFrequency() << "s\n";
    std::cout << "Average FPS:     " << static_cast<double>(totalFramesRendered)* SDL_GetPerformanceFrequency() / totalTicks << "\n";

    Render::Shutdown(&pWindow, &pRenderer, &pTexture);
    
    return 0;
}